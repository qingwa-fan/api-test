import osimport pytestimport allurefrom common.contants import DATA_DIRfrom common.my_log import Loggerfrom common.read_json import ReadJsonfrom common.handle_request import HandleRequestfrom common.handle_oracle import HandleDbfrom common.config import confTEST_DATA_PLAN = os.path.join(DATA_DIR, "test_fdp_login_cases.json")logging = Logger(__name__).get_logger()@allure.feature('FDP登录接口')@allure.testcase(conf.get("project_url", "url"), "测试地址：{}".format(conf.get("project_url", "url")))class TestLogin():    # 准备    json_object = ReadJson(TEST_DATA_PLAN)    json_datas = json_object.read_json()    cases = json_datas["cases"]    http = HandleRequest()    db = HandleDb()    #    # @pytest.fixture(scope="module")    # def my_fixture(fdp):    #     #前置处理    #     print('开始测试登录接口')    #    #     yield    #     # 后置处理 删除测试数据    #     fdp.db.del_data("DELETE  FROM SYS_LOGININFOR WHERE INFO_ID IN (SELECT  max(INFO_ID) FROM "    #                     "SYS_LOGININFOR WHERE USER_NAME ='admin' AND "    #                     "LOGIN_TIME >= TIMESTAMP'2023-05-31 00:00:00.000')")    #    #     fdp.db.close()    # 类级前置操作    def setup_class(self):        print('------>执行前置操作')        print('开始测试登录接口')    def teardown_class(self):        print('------>执行后置操作,删除最后一次登录信息')        self.db.del_data("DELETE  FROM SYS_LOGININFOR WHERE INFO_ID IN (SELECT  max(INFO_ID) FROM "                                            "SYS_LOGININFOR WHERE USER_NAME ='admin' AND "                                            "LOGIN_TIME >= TIMESTAMP'2023-05-31 00:00:00.000')")        self.db.close()    # 被fixture装饰的方法将会自动传入每个测试用例方法中，不需要自己传入所装饰的方法    @pytest.fixture()    # request.param：用于获取测试的请求参数    def case_data(self, request):        casedata = request.param        return casedata    @allure.title("测试用账号密码进行登录")    @allure.story("用正确的账号密码进行登录")    @allure.description("用正确的账号密码进行登录FDP，验证登录过程")    # @pytest.mark.flaky(reruns=1, reruns_delay=1)    # 1、@pytest.mark.parametrize('case_data', cases)    #    # 2、@pytest.mark.parametrize('case_data', cases, indirect=True)    #    # 当引用1的时候，case_data是一个变量，执行后的结果就是case_data = [{'user': 'admin', 'pwd': ''}],    #    # 当使用2的时候，case_data是一个可执行的函数，再将cases当参数传入case_data函数中去执行    @pytest.mark.parametrize('case_data', cases, indirect=True)    def test_login(self, case_data):        logging.info("****************正在执行：test_use_right_account_login***************")        with allure.step("准备测试数据"):            url = conf.get("project_url", "url") + case_data["url"]            method = case_data["method"]            # 预期结果            expected = case_data["expected"]        # 请求接口        with allure.step("执行接口请求"):            response = self.http.send(url=url, method=method, json=case_data["json"])            result = response.json()            # 记录最后一次登录信息            try:                Last_login = self.db.get_one(                    "SELECT * FROM SYS_LOGININFOR WHERE INFO_ID IN (SELECT  max(INFO_ID) FROM "                    "SYS_LOGININFOR WHERE USER_NAME ='admin' "                    "AND LOGIN_TIME >= TIMESTAMP'2023-05-31 00:00:00.000')")            except KeyError:                pass        with allure.step("进行预期结果断言"):            try:                # 请求体断言                assert expected["code"] == result["code"]                assert expected["msg"] == result["msg"]                # 数据库断言                if case_data["check_sql"]:                        Login_results = {msg for msg in list(self.db.get_all(case_data["check_sql"]))}                        try:                            Login_results = result["msg"]                            print('用例执行通过')                        except KeyError:                            print('用例执行失败')            except AssertionError as i:                logging.error("{}用例{}--执行失败!".format(case_data["title"], case_data["case_id"]))                logging.debug(                    "{}用例{}--失败请求参数：{}".format(case_data["title"], case_data["case_id"], case_data["json"]))                logging.error("{}用例{}--失败请求返回参数：{}".format(case_data["title"], case_data["case_id"], result))                logging.error("{}用例{}--报错信息：{}".format(case_data["title"], case_data["case_id"], i))                logging.debug("{}用例{}--预期结果：{}".format(case_data["title"], case_data["case_id"], expected))                raise i            else:                logging.info("用例：{}-{}--执行通过".format(case_data["title"], case_data["case_id"]))if __name__ == '__main__':    self_test_login = TestLogin()    self_test_login.test_login()